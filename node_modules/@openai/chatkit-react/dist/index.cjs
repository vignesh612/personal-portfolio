"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  ChatKit: () => ChatKit,
  useChatKit: () => useChatKit
});
module.exports = __toCommonJS(index_exports);

// src/ChatKit.tsx
var React = __toESM(require("react"), 1);
var import_jsx_runtime = require("react/jsx-runtime");
var EVENT_HANDLER_MAP = {
  "chatkit.error": "onError",
  "chatkit.response.end": "onResponseEnd",
  "chatkit.response.start": "onResponseStart",
  "chatkit.log": "onLog",
  "chatkit.thread.change": "onThreadChange",
  "chatkit.thread.load.start": "onThreadLoadStart",
  "chatkit.thread.load.end": "onThreadLoadEnd",
  "chatkit.ready": "onReady",
  "chatkit.effect": "onEffect"
};
var EVENT_NAMES = Object.keys(EVENT_HANDLER_MAP);
var ChatKit = React.forwardRef(
  function ChatKit2({ control, ...htmlProps }, forwardedRef) {
    const ref = React.useRef(null);
    React.useLayoutEffect(() => {
      const el = ref.current;
      if (!el) return;
      if (customElements.get("openai-chatkit")) {
        el.setOptions(control.options);
        return;
      }
      let active = true;
      customElements.whenDefined("openai-chatkit").then(() => {
        if (active) {
          el.setOptions(control.options);
        }
      });
      return () => {
        active = false;
      };
    }, [control.options]);
    React.useEffect(() => {
      const el = ref.current;
      if (!el) return;
      const controller = new AbortController();
      for (const eventName of EVENT_NAMES) {
        el.addEventListener(
          eventName,
          (e) => {
            const handlerName = EVENT_HANDLER_MAP[eventName];
            const handler = control.handlers[handlerName];
            if (typeof handler === "function") {
              handler(e.detail);
            }
          },
          { signal: controller.signal }
        );
      }
      return () => {
        controller.abort();
      };
    }, [control.handlers]);
    return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
      "openai-chatkit",
      {
        ref: (chatKit) => {
          ref.current = chatKit;
          control.setInstance(chatKit);
          if (typeof forwardedRef === "function") {
            forwardedRef(chatKit);
          } else if (forwardedRef) {
            forwardedRef.current = chatKit;
          }
          if (!ref.current) {
            return;
          }
        },
        ...htmlProps
      }
    );
  }
);

// src/useChatKit.ts
var React3 = __toESM(require("react"), 1);

// src/useStableOptions.ts
var import_react = __toESM(require("react"), 1);
function isPlainObjectOrArray(obj) {
  return obj !== null && typeof obj === "object" && [null, Object.prototype].includes(Object.getPrototypeOf(obj)) || Array.isArray(obj);
}
function deepEqualIgnoringFns(a, b, seen = /* @__PURE__ */ new WeakMap()) {
  if (Object.is(a, b)) return true;
  if (typeof a === "function" && typeof b === "function") {
    return typeof a === typeof b;
  }
  if (!isPlainObjectOrArray(a) || !isPlainObjectOrArray(b)) {
    return false;
  }
  const mapped = seen.get(a);
  if (mapped && mapped === b) return true;
  seen.set(a, b);
  if (Array.isArray(a) || Array.isArray(b)) {
    if (!Array.isArray(a) || !Array.isArray(b) || a.length !== b.length)
      return false;
    for (let i = 0; i < a.length; i++) {
      if (!deepEqualIgnoringFns(a[i], b[i], seen)) return false;
    }
    return true;
  }
  const aKeys = Object.keys(a);
  const bKeys = Object.keys(b);
  if (aKeys.length !== bKeys.length) return false;
  for (let i = 0; i < aKeys.length; i++) {
    const k = aKeys[i];
    if (!Object.prototype.hasOwnProperty.call(b, k)) return false;
    const av = a[k];
    const bv = b[k];
    if (!deepEqualIgnoringFns(av, bv, seen)) return false;
  }
  return true;
}
function withLatestFunctionWrappers(ref) {
  const path = [];
  const getByPath = (root, p) => p.reduce((acc, k) => acc == null ? acc : acc[k], root);
  const wrap = (parentPath, key) => {
    return (...args) => {
      const latestParent = getByPath(ref.current, parentPath);
      const latestFn = latestParent?.[key];
      if (typeof latestFn === "function") {
        return latestFn.apply(latestParent, args);
      }
    };
  };
  const visit = (v) => {
    if (typeof v === "function") {
      const key = path[path.length - 1];
      const parentPath = path.slice(0, -1);
      return wrap(parentPath, key);
    }
    if (Array.isArray(v)) {
      const base = path.length;
      const out = new Array(v.length);
      for (let i = 0; i < v.length; i++) {
        path[base] = i;
        out[i] = visit(v[i]);
      }
      path.length = base;
      return out;
    }
    if (v && typeof v === "object") {
      const base = path.length;
      const out = {};
      for (const k of Object.keys(v)) {
        path[base] = k;
        out[k] = visit(v[k]);
      }
      path.length = base;
      return out;
    }
    return v;
  };
  return visit(ref.current);
}
function useStableOptions(options) {
  const latestOptions = import_react.default.useRef(options);
  latestOptions.current = options;
  const cache = import_react.default.useRef(null);
  if (!cache.current || !deepEqualIgnoringFns(cache.current.snapshot, options)) {
    cache.current = {
      snapshot: options,
      shaped: withLatestFunctionWrappers(latestOptions)
    };
  }
  return cache.current.shaped;
}

// src/useChatKit.ts
var CHATKIT_METHOD_NAMES = Object.freeze([
  "focusComposer",
  "setThreadId",
  "sendUserMessage",
  "setComposerValue",
  "fetchUpdates",
  "sendCustomAction"
]);
function useChatKit(options) {
  const ref = React3.useRef(null);
  const stableOptions = useStableOptions(options);
  const methods = React3.useMemo(() => {
    return CHATKIT_METHOD_NAMES.reduce((acc, key) => {
      acc[key] = (...args) => {
        if (!ref.current) {
          console.warn("ChatKit element is not mounted");
          return;
        }
        return ref.current[key](...args);
      };
      return acc;
    }, {});
  }, []);
  const setInstance = React3.useCallback(
    (instance) => {
      ref.current = instance;
    },
    []
  );
  const control = React3.useMemo(() => {
    const options2 = {};
    const handlers = {};
    for (const [key, value] of Object.entries(stableOptions)) {
      if (/^on[A-Z]/.test(key) && key !== "onClientTool") {
        handlers[key] = value;
      } else {
        options2[key] = value;
      }
    }
    return {
      setInstance,
      options: options2,
      handlers
    };
  }, [stableOptions, setInstance]);
  return React3.useMemo(
    () => ({ ...methods, control, ref }),
    [methods, control]
  );
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ChatKit,
  useChatKit
});
